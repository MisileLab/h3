---
import {HoverType, AnimationType} from "./lib"

export interface Props {
  hover?: HoverType,
  completeTime?: number,
  animationType?: AnimationType,
  id?: string,
  initialTime?: number
}
const { hover = HoverType.reanimate, completeTime = 0.8, animationType = AnimationType.normal, id = "", initialTime = 0 } = Astro.props;
---

<astro-animation data-hover={hover} data-completeTime={completeTime} data-animationType={animationType} data-initialTime={initialTime} id={id}>
  <slot />
</astro-animation>
<script>
  import { parseFloat, nullVerify } from "@misile/satellite"
  import { normalHide, normalShow, randomHide, randomShow, isRealInside, AnimationValue } from "./lib"
  import { atom } from "nanostores"

  class AstroAnimation extends HTMLElement {
    private hovered = atom<boolean>(false);
    private animationProgress = atom<AnimationValue>(AnimationValue.done);
    private functions: {over: (()=>void), out: (()=>void)} = {over: ()=>{}, out: ()=>{}};
    private first = true;
    private org = "";

    constructor() {
      super();
      let tmp = this;
      let realv = tmp.childNodes[0] as HTMLElement;
      while (realv != null && realv.nodeType == Node.TEXT_NODE) {
        realv = realv.nextSibling as HTMLElement;
      }
      this.org = realv.innerText ?? realv.textContent;
      const observer = new MutationObserver(function(mutations) {
        for (let i=0;i<mutations.length;i++) {
          if (mutations[i].addedNodes.length) {
            if (tmp.animationProgress.get() == AnimationValue.done) {
              tmp.connectedCallback();
            }
            break;
          }
        }
      });
      observer.observe(tmp, {childList: true, subtree: true});
      tmp.hovered.subscribe((hovered)=>{
        if (tmp.animationProgress.get() == AnimationValue.done) {
          if (hovered) {tmp.functions.over()} else {tmp.functions.out()}
        }
      })
    }

    connectedCallback() {
      const d = this.dataset;
      const childNodes = this.childNodes;
      const hover = nullVerify(d.hover);
      const completeTime = parseFloat(nullVerify(d.completetime)) * 1000;
      const animationType = nullVerify(d.animationtype);
      const connectedCallback = this.connectedCallback;
      let realv = childNodes[0] as HTMLElement;
      while (realv != null && realv.nodeType == Node.TEXT_NODE) {
        realv = realv.nextSibling as HTMLElement;
      }
      let org = realv.innerText ?? realv.textContent;
      if (Array(org).filter(v => v == "_").length == 0) {
        org = this.org;
      }
      const aps = completeTime / org.length;
      const functions = {over: ()=>{}, out: ()=>{}};
      document.addEventListener('mousemove', (e)=>{
        this.hovered.set(isRealInside(realv, e))
      });
      if (hover == "reanimate") {
        if (animationType == "normal" || animationType == 'rewind') {
          functions.over = ()=>{
            this.animationProgress.set(AnimationValue.doing);
            normalHide(connectedCallback, realv, animationType == 'rewind', aps/2, 0, this.animationProgress, true);
            normalShow(connectedCallback, realv, org, animationType == 'rewind', aps/2, aps*(realv.innerText.length/2), this.animationProgress);
          };
        } else {
          functions.over = ()=>{
            this.animationProgress.set(AnimationValue.doing);
            randomHide(connectedCallback, realv, aps/2, 0, this.animationProgress, true);
            randomShow(connectedCallback, realv, org, aps/2, aps*(realv.innerText.length/2), this.animationProgress);
          }
        }
      } else if (hover == "hide") {
        if (animationType == "normal" || animationType == 'rewind') {
          functions.over = ()=>{
            this.animationProgress.set(AnimationValue.doing);
            normalHide(connectedCallback, realv, animationType == 'rewind', aps, 0, this.animationProgress);
          }
          functions.out = ()=>{
            this.animationProgress.set(AnimationValue.doing);
            normalShow(connectedCallback, realv, org, animationType == 'rewind', aps, 0, this.animationProgress);
          }
        } else {
          functions.over = ()=>{
            this.animationProgress.set(AnimationValue.doing);
            randomHide(connectedCallback, realv, aps, 0, this.animationProgress);
          }
          functions.out = ()=>{
            this.animationProgress.set(AnimationValue.doing);
            randomShow(connectedCallback, realv, org, aps, 0, this.animationProgress);
          }
        }
      } else if (hover == "show") {
        if (animationType == "normal" || animationType == 'rewind') {
          functions.over = ()=>{
            this.animationProgress.set(AnimationValue.doing);
            normalShow(connectedCallback, realv, org, animationType == 'rewind', aps, 0, this.animationProgress);
          }
          functions.out = ()=>{
            this.animationProgress.set(AnimationValue.doing);
            normalHide(connectedCallback, realv, animationType == 'rewind', aps, 0, this.animationProgress);
          }
        } else {
          functions.over = ()=>{
            this.animationProgress.set(AnimationValue.doing);
            randomShow(connectedCallback, realv, org, aps, 0, this.animationProgress);
          }
          functions.out = ()=>{
            this.animationProgress.set(AnimationValue.doing);
            randomHide(connectedCallback, realv, aps, 0, this.animationProgress);
          }
        }
      }
      this.functions = functions;
      if (this.first) {this.first = false;setTimeout(functions.out, parseFloat(nullVerify(d.initialTime)) * 1000)}
    }
  }

  customElements.define('astro-animation', AstroAnimation)
</script>

