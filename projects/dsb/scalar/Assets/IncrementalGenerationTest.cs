using UnityEngine;
using UnityEngine.UI;
using System.Collections;

namespace Scalar
{
    /// <summary>
    /// Test script specifically for demonstrating incremental graph generation
    /// </summary>
    public class IncrementalGenerationTest : MonoBehaviour
    {
        [Header("UI References")]
        [SerializeField] private Text statusText;
        [SerializeField] private Text progressText;
        [SerializeField] private Slider progressSlider;
        [SerializeField] private Button generateChunkButton;
        [SerializeField] private Button movePartyButton;
        [SerializeField] private Button resetButton;
        
        [Header("Test Settings")]
        [SerializeField] private float updateInterval = 0.5f;
        [SerializeField] private bool autoGenerate = false;
        [SerializeField] private float autoGenerateDelay = 2.0f;
        
        private GraphSystem graphSystem;
        private GraphVisualizer graphVisualizer;
        private Coroutine autoGenerateCoroutine;
        
        void Start()
        {
            // Find required components
            graphSystem = FindFirstObjectByType<GraphSystem>();
            graphVisualizer = FindFirstObjectByType<GraphVisualizer>();
            
            if (graphSystem == null)
            {
                Debug.LogError("IncrementalGenerationTest: No GraphSystem found in scene!");
                return;
            }
            
            // Setup UI
            SetupUI();
            
            // Start status updates
            StartCoroutine(UpdateStatus());
            
            // Start auto-generation if enabled
            if (autoGenerate)
            {
                StartAutoGeneration();
            }
            
            Debug.Log("IncrementalGenerationTest: Test system initialized for incremental generation testing");
        }
        
        /// <summary>
        /// Setup the UI elements
        /// </summary>
        private void SetupUI()
        {
            if (generateChunkButton != null)
            {
                generateChunkButton.onClick.AddListener(GenerateNextChunk);
            }
            
            if (movePartyButton != null)
            {
                movePartyButton.onClick.AddListener(MovePartyForward);
            }
            
            if (resetButton != null)
            {
                resetButton.onClick.AddListener(ResetTest);
            }
        }
        
        /// <summary>
        /// Update status information
        /// </summary>
        private IEnumerator UpdateStatus()
        {
            while (true)
            {
                UpdateStatusDisplay();
                yield return new WaitForSeconds(updateInterval);
            }
        }
        
        /// <summary>
        /// Update the status display
        /// </summary>
        private void UpdateStatusDisplay()
        {
            if (graphSystem == null) return;
            
            // Update status text
            if (statusText != null)
            {
                string status = $"Graph Status:\n";
                status += $"Total Nodes: {graphSystem.GetTotalNodeCount()}\n";
                status += $"Completed: {graphSystem.GetCompletedNodeCount()}\n";
                status += $"Current Depth: {graphSystem.GetCurrentDepth()}\n";
                status += $"Graph Generated: {graphSystem.IsGraphGenerated()}\n";
                
                // Add incremental generation info using reflection
                var lastGeneratedDepth = graphSystem.GetType().GetField("lastGeneratedDepth", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(graphSystem);
                var chunkSize = graphSystem.GetType().GetField("chunkSize", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(graphSystem);
                var maxGeneratedDepth = graphSystem.GetType().GetField("maxGeneratedDepth", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(graphSystem);
                
                if (lastGeneratedDepth != null && chunkSize != null && maxGeneratedDepth != null)
                {
                    status += $"Incremental Generation: {lastGeneratedDepth}/{maxGeneratedDepth}\n";
                    status += $"Generated Chunks: {((int)lastGeneratedDepth / (int)chunkSize)}\n";
                    status += $"Chunk Size: {chunkSize}\n";
                }
                
                statusText.text = status;
            }
            
            // Update progress bar
            if (progressSlider != null)
            {
                var lastGeneratedDepth = graphSystem.GetType().GetField("lastGeneratedDepth", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(graphSystem);
                var maxGeneratedDepth = graphSystem.GetType().GetField("maxGeneratedDepth", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(graphSystem);
                
                if (lastGeneratedDepth != null && maxGeneratedDepth != null)
                {
                    float progress = (float)(int)lastGeneratedDepth / (int)maxGeneratedDepth;
                    progressSlider.value = progress;
                }
            }
            
            // Update progress text
            if (progressText != null)
            {
                var lastGeneratedDepth = graphSystem.GetType().GetField("lastGeneratedDepth", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(graphSystem);
                var maxGeneratedDepth = graphSystem.GetType().GetField("maxGeneratedDepth", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(graphSystem);
                
                if (lastGeneratedDepth != null && maxGeneratedDepth != null)
                {
                    float progress = (float)(int)lastGeneratedDepth / (int)maxGeneratedDepth * 100f;
                    progressText.text = $"Progress: {progress:F1}%";
                }
            }
        }
        
        /// <summary>
        /// Generate the next chunk manually
        /// </summary>
        public void GenerateNextChunk()
        {
            if (graphSystem == null) return;
            
            var method = graphSystem.GetType().GetMethod("GenerateChunkManually", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
            if (method != null)
            {
                var lastGeneratedDepth = graphSystem.GetType().GetField("lastGeneratedDepth", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(graphSystem);
                var chunkSize = graphSystem.GetType().GetField("chunkSize", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(graphSystem);
                
                if (lastGeneratedDepth != null && chunkSize != null)
                {
                    int nextChunkId = (int)lastGeneratedDepth / (int)chunkSize;
                    method.Invoke(graphSystem, new object[] { nextChunkId });
                    Debug.Log($"Manually generated chunk {nextChunkId}");
                }
            }
        }
        
        /// <summary>
        /// Move the main party forward to trigger automatic generation
        /// </summary>
        public void MovePartyForward()
        {
            if (graphSystem == null) return;
            
            var mainParty = graphSystem.GetParty("party_main");
            if (mainParty == null) return;
            
            // Move party to the right (deeper into the graph)
            Vector2Int newPosition = mainParty.currentNodePosition + new Vector2Int(1, 0);
            
            if (graphSystem.MoveParty("party_main", newPosition))
            {
                Debug.Log($"Moved party to {newPosition} to trigger generation");
                
                // Update the visualization to show newly discovered nodes
                if (graphVisualizer != null)
                {
                    graphVisualizer.UpdateVisualization();
                }
            }
            else
            {
                Debug.Log("Could not move party - no accessible node in that direction");
            }
        }
        
        /// <summary>
        /// Reset the test by clearing visualization and regenerating
        /// </summary>
        public void ResetTest()
        {
            if (graphVisualizer != null)
            {
                graphVisualizer.ClearVisualization();
            }
            
            // Note: In a real implementation, you'd reset the graph system
            Debug.Log("Test reset - visualization cleared");
        }
        
        /// <summary>
        /// Start automatic chunk generation
        /// </summary>
        public void StartAutoGeneration()
        {
            if (autoGenerateCoroutine != null)
            {
                StopCoroutine(autoGenerateCoroutine);
            }
            
            autoGenerateCoroutine = StartCoroutine(AutoGenerateChunks());
        }
        
        /// <summary>
        /// Stop automatic chunk generation
        /// </summary>
        public void StopAutoGeneration()
        {
            if (autoGenerateCoroutine != null)
            {
                StopCoroutine(autoGenerateCoroutine);
                autoGenerateCoroutine = null;
            }
        }
        
        /// <summary>
        /// Automatically generate chunks at intervals
        /// </summary>
        private IEnumerator AutoGenerateChunks()
        {
            while (true)
            {
                yield return new WaitForSeconds(autoGenerateDelay);
                GenerateNextChunk();
            }
        }
        
        /// <summary>
        /// Toggle auto-generation
        /// </summary>
        public void ToggleAutoGeneration()
        {
            autoGenerate = !autoGenerate;
            
            if (autoGenerate)
            {
                StartAutoGeneration();
            }
            else
            {
                StopAutoGeneration();
            }
        }
        
        /// <summary>
        /// Manually update the graph visualization
        /// </summary>
        public void UpdateVisualization()
        {
            if (graphVisualizer != null)
            {
                graphVisualizer.UpdateVisualization();
                Debug.Log("Manually updated graph visualization");
            }
        }
        
        /// <summary>
        /// Reveal nodes around the current player position
        /// </summary>
        public void RevealNodesAroundPlayer()
        {
            if (graphVisualizer != null)
            {
                graphVisualizer.RevealNodesAroundPlayer("party_main");
                Debug.Log("Revealed nodes around player position");
            }
        }
        
        /// <summary>
        /// Center camera on the main party
        /// </summary>
        public void CenterCameraOnMainParty()
        {
            var partyVisualizer = FindFirstObjectByType<PartyVisualizer>();
            if (partyVisualizer != null)
            {
                partyVisualizer.CenterCameraOnParty("party_main");
                Debug.Log("Centered camera on main party");
            }
            else
            {
                Debug.LogWarning("No PartyVisualizer found in scene");
            }
        }
        
        /// <summary>
        /// Center camera on main party and make it look at the party
        /// </summary>
        public void CenterCameraOnMainPartyAndLookAt()
        {
            var partyVisualizer = FindFirstObjectByType<PartyVisualizer>();
            if (partyVisualizer != null)
            {
                partyVisualizer.CenterCameraOnPartyAndLookAt("party_main");
                Debug.Log("Centered camera on main party and will look at it");
            }
            else
            {
                Debug.LogWarning("No PartyVisualizer found in scene");
            }
        }
        
        /// <summary>
        /// Toggle auto-camera centering (deprecated - use CameraZoomSystem instead)
        /// </summary>
        public void ToggleAutoCameraCentering()
        {
            Debug.Log("Auto-camera centering is deprecated. Use CameraZoomSystem for camera controls.");
        }
        
        /// <summary>
        /// Reset camera to default position and zoom
        /// </summary>
        public void ResetCamera()
        {
            var cameraSystem = FindFirstObjectByType<CameraZoomSystem>();
            if (cameraSystem != null)
            {
                cameraSystem.ResetCamera();
                Debug.Log("Camera reset to default position and zoom");
            }
            else
            {
                Debug.LogWarning("No CameraZoomSystem found in scene");
            }
        }
        
        /// <summary>
        /// Toggle edge scrolling
        /// </summary>
        public void ToggleEdgeScrolling()
        {
            var cameraSystem = FindFirstObjectByType<CameraZoomSystem>();
            if (cameraSystem != null)
            {
                cameraSystem.ToggleEdgeScrolling();
            }
            else
            {
                Debug.LogWarning("No CameraZoomSystem found in scene");
            }
        }
        
        /// <summary>
        /// Toggle WASD movement
        /// </summary>
        public void ToggleWASD()
        {
            var cameraSystem = FindFirstObjectByType<CameraZoomSystem>();
            if (cameraSystem != null)
            {
                cameraSystem.ToggleWASD();
            }
            else
            {
                Debug.LogWarning("No CameraZoomSystem found in scene");
            }
        }
        
        /// <summary>
        /// Toggle mouse panning
        /// </summary>
        public void ToggleMousePan()
        {
            var cameraSystem = FindFirstObjectByType<CameraZoomSystem>();
            if (cameraSystem != null)
            {
                cameraSystem.ToggleMousePan();
            }
            else
            {
                Debug.LogWarning("No CameraZoomSystem found in scene");
            }
        }
        
        /// <summary>
        /// Debug camera positions
        /// </summary>
        public void DebugCameraPositions()
        {
            var partyVisualizer = FindFirstObjectByType<PartyVisualizer>();
            if (partyVisualizer != null)
            {
                Debug.Log($"PartyVisualizer camera target: {partyVisualizer.GetCurrentCameraTarget()}");
                Debug.Log($"PartyVisualizer camera moving: {partyVisualizer.IsCameraMoving()}");
            }
            else
            {
                Debug.LogWarning("No PartyVisualizer found in scene");
            }
            
            var cameraSystem = FindFirstObjectByType<CameraZoomSystem>();
            if (cameraSystem != null)
            {
                Debug.Log($"CameraZoomSystem target position: {cameraSystem.GetTargetPosition()}");
                Debug.Log($"CameraZoomSystem target zoom: {cameraSystem.GetTargetZoom()}");
                Debug.Log($"CameraZoomSystem following: {cameraSystem.IsFollowing()}");
                Debug.Log($"CameraZoomSystem panning: {cameraSystem.IsPanning()}");
            }
            else
            {
                Debug.LogWarning("No CameraZoomSystem found in scene");
            }
        }
        
        /// <summary>
        /// Focus camera on main party
        /// </summary>
        public void FocusOnMainParty()
        {
            var cameraSystem = FindFirstObjectByType<CameraZoomSystem>();
            if (cameraSystem != null)
            {
                cameraSystem.FocusOnMainPartyPublic();
                Debug.Log("IncrementalGenerationTest: Focused camera on main party");
            }
            else
            {
                Debug.LogWarning("IncrementalGenerationTest: No CameraZoomSystem found, cannot focus on main party");
            }
        }
        
        void OnDestroy()
        {
            StopAutoGeneration();
        }
    }
}
