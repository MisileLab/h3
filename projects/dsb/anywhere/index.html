<!DOCTYPE html>
<html>
<head>
  <title>A* Algorithm Visualization</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #map {
      height: 500px;
      width: 80%;
      margin-top: 20px;
    }
    .controls {
      margin-top: 20px;
    }
    button {
      padding: 10px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <h1>A* Algorithm Visualization</h1>
  <p>Click on the map to select a start and end point. Then click the visualize button to see the A* algorithm in action.</p>
  <div id="map"></div>
  <div class="controls">
    <button id="visualize">Visualize</button>
    <button id="reset">Reset</button>
  </div>
  <div id="loading" style="display: none;">Loading...</div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([51.505, -0.09], 13);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);

async function getRoads(bounds) {
  const query = `
    [out:json];
    (
      way["highway"]
         (${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()});
    );
    (._;>;);
    out body;
  `;
  const response = await fetch('https://overpass-api.de/api/interpreter', {
    method: 'POST',
    body: query
  });
  const data = await response.json();
  return data;
}

let startMarker, endMarker;
let startPoint, endPoint;

map.on('click', function(e) {
  if (!startPoint) {
    startPoint = e.latlng;
    startMarker = L.marker(startPoint).addTo(map).bindPopup('Start').openPopup();
  } else if (!endPoint) {
    endPoint = e.latlng;
    endMarker = L.marker(endPoint).addTo(map).bindPopup('End').openPopup();
  }
});

document.getElementById('visualize').addEventListener('click', async () => {
  if (!startPoint || !endPoint) {
    alert('Please select start and end points.');
    return;
  }

  document.getElementById('loading').style.display = 'block';

  const bounds = map.getBounds();
  const osmData = await getRoads(bounds);

  const nodes = {};
  const ways = {};

  for (const element of osmData.elements) {
    if (element.type === 'node') {
      nodes[element.id] = {
        id: element.id,
        lat: element.lat,
        lon: element.lon,
        neighbors: []
      };
    } else if (element.type === 'way') {
      ways[element.id] = element.nodes;
      for (let i = 0; i < element.nodes.length - 1; i++) {
        const node1 = nodes[element.nodes[i]];
        const node2 = nodes[element.nodes[i + 1]];
        if (node1 && node2) {
          node1.neighbors.push(node2);
          node2.neighbors.push(node1);
        }
      }
    }
  }

  let startNode = findClosestNode(startPoint, nodes);
  let endNode = findClosestNode(endPoint, nodes);

  if (!startNode || !endNode) {
    alert('Could not find a road near the selected points. Please try again.');
    document.getElementById('loading').style.display = 'none';
    return;
  }

  if (startNode === endNode) {
    alert('Start and end points are the same.');
    document.getElementById('loading').style.display = 'none';
    return;
  }

  const openSet = [startNode];
  const closedSet = [];

  startNode.g = 0;
  startNode.h = heuristic(startNode, endNode);
  startNode.f = startNode.g + startNode.h;

  function findClosestNode(point, nodes) {
    let closestNode = null;
    let minDistance = Infinity;

    for (const nodeId in nodes) {
      const node = nodes[nodeId];
      const distance = L.latLng(point.lat, point.lng).distanceTo(L.latLng(node.lat, node.lon));
      if (distance < minDistance) {
        minDistance = distance;
        closestNode = node;
      }
    }
    return closestNode;
  }

  function heuristic(a, b) {
    return L.latLng(a.lat, a.lon).distanceTo(L.latLng(b.lat, b.lon));
  }

  function animate() {
    if (openSet.length > 0) {
      let lowestIndex = 0;
      for (let i = 0; i < openSet.length; i++) {
        if (openSet[i].f < openSet[lowestIndex].f) {
          lowestIndex = i;
        }
      }

      const current = openSet[lowestIndex];

      if (current === endNode) {
        let path = [];
        let temp = current;
        path.push(temp);
        while (temp.previous) {
          path.push(temp.previous);
          temp = temp.previous;
        }

        const latlngs = path.map(p => L.latLng(p.lat, p.lon));
        L.polyline(latlngs, { color: 'blue' }).addTo(map);
        document.getElementById('loading').style.display = 'none';
        return;
      }

      openSet.splice(lowestIndex, 1);
      closedSet.push(current);

      const neighbors = current.neighbors;
      for (let i = 0; i < neighbors.length; i++) {
        const neighbor = neighbors[i];

        if (!closedSet.includes(neighbor)) {
          const tempG = current.g + heuristic(current, neighbor);

          if (openSet.includes(neighbor)) {
            if (tempG < neighbor.g) {
              neighbor.g = tempG;
            }
          } else {
            neighbor.g = tempG;
            openSet.push(neighbor);
          }

          neighbor.h = heuristic(neighbor, endNode);
          neighbor.f = neighbor.g + neighbor.h;
          neighbor.previous = current;
        }
      }

      for (let i = 0; i < openSet.length; i++) {
        const node = openSet[i];
        L.circleMarker([node.lat, node.lon], { radius: 1, color: 'green' }).addTo(map);
      }

      for (let i = 0; i < closedSet.length; i++) {
        const node = closedSet[i];
        L.circleMarker([node.lat, node.lon], { radius: 1, color: 'red' }).addTo(map);
      }

      requestAnimationFrame(animate);
    } else {
      alert('No solution found');
      document.getElementById('loading').style.display = 'none';
    }
  }

  animate();
});



document.getElementById('reset').addEventListener('click', () => {
  document.getElementById('loading').style.display = 'block';
  map.eachLayer((layer) => {
    if (layer instanceof L.Marker || layer instanceof L.Path) {
      map.removeLayer(layer);
    }
  });
  startPoint = null;
  endPoint = null;
  startMarker = null;
  endMarker = null;
  document.getElementById('loading').style.display = 'none';
});
  </script>
</body>
</html>
