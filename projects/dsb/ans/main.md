알고리즘: 문제를 해결하기 위한 방법

# 좋은 알고리즘의 조건

- 속도가 빨라야 함
  - 상황에 따라 세 가지로 나눔(최악(Big O), 보통(omega), 최선(세타))
  - Big O Notation 사용
    - Big O Notation = O(n)식으로 표기하는 것
    - 상대적으로 의미없는 수(최고차항을 제외한 나머지와 최고차항의 계수)를 제외함
- 공간을 적게 차지해야 함(보통 메모리 공간을 의미)

# 선택 정렬

속도: O(n^2)

## 초기 변수

배열의 첫번째 값은 1로 가정, i=1

## 방법

- 배열의 최솟값과 i를 바꾸기
- i를 1 증가
- i가 배열의 길이-1과 같을 때까지 반복 

## 시뮬레이션

[SelectionSort Simulation](https://raw.githubusercontent.com/MisileLab/h3/main/projects/dsb/ans/simulations/SelectionSort.mp4)

# 삽입 정렬

속도: O(n^2)

## 안정성이 있는 이유

안정성: 동일한 값의 순서가 변경되지 않는것
동일한 값이 왼쪽에 있을 때 비교할 시, 비교는 하지만 이동하지 않고, 오른쪽에 있을 때는 비교하지 않음

## 방법

- 리스트 안에 정렬할 값을 n이라고 가정
- 배열 중 적절한 자리(왼쪽 수가 n보다 작고 오른쪽 수가 n보다 큰 자리)에 배치

## 성능

- 가장 빠르게 정렬되는 경우
  - 모두 정렬되어 있을 때
  - 총 비교 횟수: n-1
  - 이동 횟수: 0
- 가장 느리게 정렬되는 경우
  - 역순으로 정렬되어 있을 때
  - 총 비교 횟수: n(n-1)/2
    - 각 반복에서 1번의 비교가 수행됨
    - 각 단계에서 i-1번의 비교가 수행됨
  - 총 이동 횟수: n(n-1)/2
    - 각 단계에서 i번의 이동이 수행됨

## [3,7,9,4,1,6]때의 시뮬레이션

[InsertionSort-pinned Simulation](https://raw.githubusercontent.com/MisileLab/h3/main/projects/dsb/ans/simulations/InsertionSortPinned.mp4)

## 시뮬레이션

[InsertionSort Simulation](https://raw.githubusercontent.com/MisileLab/h3/main/projects/dsb/ans/simulations/InsertionSort.mp4)

# 버블 정렬

속도: O(n^2)

## 안정성이 있는 이유

자기 전과 자기의 요소만 바꾸기 때문에 같을 경우 교환이 일어나지 않고, 다를 경우 순서는 유지된 채로 교환이 되기 때문

## 초기 변수

- k는 배열 크기

## 방법

- n=1
- n과 n-1번째 원소를 비교하여 정렬하고, n을 1 증가시킴
- n이 k를 넘으면 종료
- 만약 전 이유로 종료했는데, 아무 교환도 하지 않았으면 정렬 완료
- k가 1일 경우 정렬 완료, 아닐 경우 k를 1 낮추고 첫번째부터 시작

## 성능

- 가장 빠르게 정렬되는 경우(이미 정렬된 경우)
  - 비교 횟수: n-1
    - 만약 교환 없이 비교만 될 경우 early-exit한다는 가정하에 n-1번만 이루어짐
  - 이동 횟수: 0
    - 이미 정렬되어 있기 때문에 이동하지 않음
- 가장 느리게 정렬되는 경우(역순 정렬된 경우)
  - 비교 횟수: n(n-1)/2
    - 각 요소를 비교해야 하지만, 한번 할 때마다 n-1번 비교하는 것이 아님
  - 이동 횟수: n(n-1)/2
    - 모든 비교 후 이동해야 하기 때문에 비교 횟수와 똑같음

## 시뮬레이션

[BubbleSort Simulation](https://raw.githubusercontent.com/MisileLab/h3/main/projects/dsb/ans/simulations/BubbleSort.mp4)

# 해싱

특정 함수에 입력값을 넣어 특정한 고정된 길이의 값으로 추출하는 것을 말함\
이론적으로 해싱한 경우 똑같은 값을 넣었을 때 똑같이 나오며, 다른 값을 넣으면 다르게 나와야 함

## 사용 범위

> 키: 해싱할 때 입력하는 값, 중복되지 않음

1. HashMap, O(1) 속도로 접근 가능
  - 키를 해싱하고, 그 곳에 값을 저장하는 방식으로 만들어짐

2. 암호화
  - 중요 정보를 해싱해 원래 정보로 복호화할 수 없게 만듬

## 해싱 충돌

다른 두개의 값이 같은 하나의 해시값을 가지는 것을 충돌이라 함\
이론적으로는 일어나지 말아야 하지만, 일어날 수 밖에 없음

# 쉘 소트

- 평균 O(n^1.5), 최악 O(n^2)

## 방법

- k=배열 크기
- k를 2로 나누고 짝수면 1을 더함
- i=0
- k-1만큼 아래 줄을 반복하고, 반복할 때마다 i를 1 증가시킴
- i번째와 i+k, i+2k...로 이루어진 배열을 k*i가 배열 크기를 넘지 않을 때까지 반복함, 이 배열을 arr[i]로 정의함
- arr 안에 있는 배열들을 모두 삽입 정렬함
- 만약 k가 1이라면 정렬됨, 아니면 두번째 스텝으로 다시 이동함

## 시뮬레이션

[Shell Simulation](https://raw.githubusercontent.com/MisileLab/h3/main/projects/dsb/ans/simulations/ShellSort.mp4)

# RSA (Rivest-Shamir-Adleman, RSA)

- 1977년에 Ron Rivest, Adi Shamir, Lenoard Adleman에 의해 개발되었다고 알려져 있음
- 1973년에 [GCHQ](https://www.gchq.gov.uk)에서 먼저 개발하고 1997년에 발표됨 - [Wikipedia](https://ko.wikipedia.org/wiki/RSA_%EC%95%94%ED%98%B8)
- 공개 키로 암호화하고, 개인 키로 해석하는 방식을 사용함

## 방법, [이 글](https://m.blog.naver.com/luexr/223146918812)을 참고함

### 키 생성

1. 큰 소수 p와 q를 선택, pk(public key)를 p와 q의 곱으로 정의
2. [오일러 Phi 함수](https://ko.wikipedia.org/wiki/%EC%98%A4%EC%9D%BC%EB%9F%AC_%ED%94%BC_%ED%95%A8%EC%88%98) f(pk) = (p - 1)(q - 1)임
3. 1과 f(pk) 안에 있고, f(pk)와 서로소인 pk2(public key 2)를 정의함
4. PK(Private Key) * pk2가 k(임의의 정수) * f(pk) + 1를 만족시키는 PK를 구함

### 암호/복호화

P(Plain text), E(Encrypted text)로 정의함

- $\equiv$는 무엇과 같다는 것을 의미하며, $=$은 무엇을 정의한다는 것을 의미함
- $mod$는 나머지를 의미함
- 암호화 식: $E \equiv P^{pk2} \mod {pk}$
- 복호화 식: $P \equiv E^{PK} \mod {pk}$

## 기타

양자컴퓨터가 상용화되면 뚫릴 가능성이 존재하나, 아직 큰 수를 소인수분해할 수 있는 양자컴퓨터가 나오지 않았으며, 상용화되기엔 시간이 오래 걸릴 것임

# 이진 탐색 트리

자신보다 작은 값의 노드를 왼쪽에 두고, 자신보다 높은 값의 노드를 오른 쪽에 두는 형태의 트리

## 검색

맨 위부터 시작해서 찾을 값이 현재 노드보다 작으면 왼쪽으로 가고, 크면 오른쪽으로 감\
만약 끝까지 갔는데 못 찾았다면 없음, 찾았다면 있는 것

## 추가(같은 값이 없다고 가정)

검색과 똑같이 하고 자기가 들어갈 자리가 있을 때까지 반복\
들어갈 자리가 생기면 자기 자신을 추가

## 삭제

만약 자기 아래에 아무것도 없다면 삭제\
만약 자기 아래에 하나의 노드가 있다면 끌어올리고 삭제\
만약 자기 아래에 두개의 노드가 있다면 오른쪽의 서브 트리의 최소 값이나 왼쪽의 최대 값 중 하나를 끌어올리고 삭제

## 시간 복잡도 - [이 글](https://www.geeksforgeeks.org/complexity-analysis-of-binary-search)을 참고

n은 보통 트리의 높이임

- 최선 복잡도: O(1)
- 보통 복잡도: O(log n)
- 최악 복잡도: O(log n)

# 데이터베이스 인덱싱

기본적으로 데이터베이스는 O(n)의 시간 복잡도로 풀 스캔함결\
인덱싱을 사용하면 O(log n)으로 줄일 수 있음

## 장점

속도 증가, 조회 성능 증가

## 단점

조회 제외 모든 성능 감소, 추가 용량, 관리 필요

# Balanced BST

잘 분배되어있는 BST는 O(log n)을 가지지만, 반대의 경우엔 O(n)을 가짐\
이를 해결하기 위해 B-Tree와 그것의 개선판인 B+Tree가 생김\
(현재 노트북의 OS도 B-Tree를 이용한 Btrfs 사용 중)

## B-Tree

- 자식 노드를 두 개 이상 가짐
- 자식 노드를 최대 n개로 가질 수 있는 n차 B-Tree라고 정의할 때
  - 각 노드는 최소 n/2개의 자식 노드를 가짐
  - 노드가 가지는 키는 최소 M/2-1, 최대 M-1임

### 검색

- 맨 위에서 시작함
- 만약 자기의 키들의 최소값보다 작으면 왼쪽으로 이동, 최댓값보다 크면 오른쪽으로 이동, 둘 다 아니면 가운데로 이동함
- 값을 찾거나 자기의 자식 노드 개수가 0이 될 때까지 위를 반복

### 삽입

- 맨 위에서 시작
- 자기의 자리를 찾을 때까지 검색의 두번째 스텝을 반복
- 적절한 자리에 삽입
- 자기 키의 개수가 최대로 가질 수 있는 키 개수 이하면 끝냄
- 만약 아니라면 지금 노드를 제외하고 부모 노드로 가서 다시 삽입 시도

## B+Tree

- B-Tree 기반
- 맨 아래의 노드만 데이터를 가짐
- 데이터 노드들은 앞 노드와 연결되어 있음
- 범위 탐색 시 효율적임

# WFC (Wave Function Collapse)

- 파동으로 이루어진 가능성을 관측해 하나의 점으로 확정된 위치를 알려줌
- 게임 레벨 디자인, 맵 생성, 디자인 모델링, 패턴 디자인에서 사용됨

## 장점

- 패턴 학습: 자기가 원하는 패턴 스타일을 만들 수 있음
- 비교적 빠른 속도

## 단점

- 지역 의존성: 주변만 비교하기 때문에 전체적으로는 안 맞을 수 있음
- 불완전 결과

# 압축 알고리즘

## 구현

- 언어: Python
- 압축 알고리즘 압축률, 속도 비교
- 허프만, RLE, LZW, BWT 등등

